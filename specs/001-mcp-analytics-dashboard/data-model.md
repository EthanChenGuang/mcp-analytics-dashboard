# Data Model: MCP Analytics Dashboard

**Date**: 2025-01-27  
**Feature**: 001-mcp-analytics-dashboard

## Overview

This document defines the data structures, entities, and relationships used in the MCP Analytics Dashboard. The data model supports time-series analytics, server classification, filtering, and theme persistence.

## Core Entities

### 1. Analytics Snapshot

Represents a point-in-time count of MCP servers at a specific timestamp.

**Type**: `AnalyticsSnapshot`

**Fields**:
```typescript
{
  timestamp: string;        // ISO 8601 UTC timestamp (e.g., "2025-01-27T14:00:00Z")
  localCount: number;       // Count of local servers (has packages)
  remoteCount: number;      // Count of remote servers (has remotes)
  totalCount: number;       // Total unique servers (localCount + remoteCount - bothCount)
  bothCount: number;        // Count of servers with both packages and remotes
  unknownCount: number;     // Count of servers with neither (excluded from main counts)
}
```

**Validation Rules**:
- `timestamp` must be valid ISO 8601 format in UTC
- All count fields must be non-negative integers
- `totalCount` should equal `localCount + remoteCount - bothCount` (servers with both are counted in both local and remote)

**Storage**: Stored as JSON array in static files generated by GitHub Actions, fetched by client

**Example**:
```json
{
  "timestamp": "2025-01-27T14:00:00Z",
  "localCount": 45,
  "remoteCount": 32,
  "totalCount": 70,
  "bothCount": 7,
  "unknownCount": 2
}
```

### 2. Time Series Data Point

Represents aggregated analytics data for a specific time period (hourly, daily, weekly, monthly).

**Type**: `TimeSeriesDataPoint`

**Fields**:
```typescript
{
  periodStart: string;      // ISO 8601 UTC timestamp for period start
  periodEnd: string;        // ISO 8601 UTC timestamp for period end
  granularity: 'hourly' | 'daily' | 'weekly' | 'monthly';
  localCount: number;       // Aggregated local server count for period
  remoteCount: number;      // Aggregated remote server count for period
  totalCount: number;       // Aggregated total server count for period
  snapshotCount: number;    // Number of snapshots aggregated in this period
}
```

**Validation Rules**:
- `periodStart` must be before or equal to `periodEnd`
- `granularity` must be one of the four allowed values
- All count fields must be non-negative integers
- `snapshotCount` must be >= 1 (at least one snapshot in period)

**Aggregation Logic**:
- **Hourly**: Use snapshot as-is (no aggregation)
- **Daily**: Aggregate all snapshots within the same calendar day (UTC)
- **Weekly**: Aggregate all snapshots within the same calendar week (Monday-Sunday, UTC)
- **Monthly**: Aggregate all snapshots within the same calendar month (UTC)

**Storage**: Computed client-side from `AnalyticsSnapshot[]` array based on selected granularity

**Example**:
```json
{
  "periodStart": "2025-01-27T00:00:00Z",
  "periodEnd": "2025-01-27T23:59:59Z",
  "granularity": "daily",
  "localCount": 45,
  "remoteCount": 32,
  "totalCount": 70,
  "snapshotCount": 24
}
```

### 3. Filter State

Represents the current filter selection applied to the analytics view.

**Type**: `FilterState`

**Fields**:
```typescript
{
  serverType: 'all' | 'local' | 'remote';
}
```

**Validation Rules**:
- `serverType` must be one of the three allowed values

**Storage**: React component state, persisted in URL query parameters for shareability

**State Transitions**:
- `all` → `local`: Show only local server counts
- `all` → `remote`: Show only remote server counts
- `local` → `all`: Show combined counts
- `local` → `remote`: Switch to remote-only view
- `remote` → `all`: Show combined counts
- `remote` → `local`: Switch to local-only view

**Example**:
```typescript
{
  serverType: 'local'
}
```

### 4. Theme Preference

Represents the user's selected theme mode.

**Type**: `ThemePreference`

**Fields**:
```typescript
{
  mode: 'light' | 'dark';
}
```

**Validation Rules**:
- `mode` must be 'light' or 'dark'

**Storage**: localStorage key `mcp-analytics-theme`

**Default Value**: `'light'` (with fallback to system preference via `prefers-color-scheme`)

**Persistence**: Survives page refreshes and browser sessions

**Example**:
```typescript
{
  mode: 'dark'
}
```

### 5. Server Classification

Represents the classification of a single MCP server from the registry API.

**Type**: `ServerType`

**Values**: `'local' | 'remote' | 'both' | 'unknown'`

**Classification Logic**:
```typescript
function classifyServer(server: Server): ServerType {
  const hasPackages = server.packages && server.packages.length > 0;
  const hasRemotes = server.remotes && server.remotes.length > 0;
  
  if (hasPackages && hasRemotes) return 'both';
  if (hasPackages) return 'local';
  if (hasRemotes) return 'remote';
  return 'unknown';
}
```

**Usage**: Used during GitHub Actions aggregation to count servers by type

### 6. MCP Registry Server (API Response)

Represents a server entry from the MCP Registry API.

**Type**: `MCPRegistryServer`

**Fields** (from API response):
```typescript
{
  server: {
    name: string;
    description?: string;
    version: string;
    packages?: Array<{
      registryType: string;
      identifier: string;
      // ... other package fields
    }>;
    remotes?: Array<{
      type: string;
      url: string;
      // ... other remote fields
    }>;
    // ... other server fields
  };
  _meta: {
    "io.modelcontextprotocol.registry/official": {
      status: string;
      publishedAt: string;  // ISO 8601 UTC timestamp
      updatedAt: string;     // ISO 8601 UTC timestamp
      isLatest: boolean;
    };
  };
}
```

**Validation Rules**:
- `server.name` must be present and non-empty
- `server.version` must be present and non-empty
- At least one of `packages` or `remotes` should be present (but neither is required)
- `_meta` must contain registry metadata

**Storage**: Fetched from API during GitHub Actions aggregation, not stored in client

## Data Flow

### 1. Data Aggregation (GitHub Actions)

```
MCP Registry API (paginated)
  ↓
GitHub Actions Workflow (hourly)
  ↓
Fetch all pages using cursor pagination
  ↓
Classify each server (local/remote/both/unknown)
  ↓
Count servers by type
  ↓
Create AnalyticsSnapshot
  ↓
Store as JSON file (public/data/analytics-YYYY-MM-DD-HH.json)
```

### 2. Data Consumption (Client)

```
Static JSON file (latest snapshot)
  ↓
Client fetches via fetch() API
  ↓
Parse AnalyticsSnapshot[]
  ↓
Apply filter (all/local/remote)
  ↓
Aggregate by granularity (hourly/daily/weekly/monthly)
  ↓
Transform to TimeSeriesDataPoint[]
  ↓
Render in chart component
```

## Relationships

### Analytics Snapshot → Time Series Data Point

- **Relationship**: One-to-many aggregation
- **Cardinality**: Multiple snapshots aggregate into one data point
- **Aggregation**: Based on granularity selection (hourly/daily/weekly/monthly)

### Filter State → Time Series Data Point

- **Relationship**: Filtering/transformation
- **Cardinality**: One filter state affects all data points
- **Effect**: Filters which counts are displayed (localCount, remoteCount, or both)

### Theme Preference → UI Rendering

- **Relationship**: Styling/display
- **Cardinality**: One theme preference affects entire application
- **Effect**: Applies CSS classes and color scheme to all components

## Data Validation

### Client-Side Validation

**Analytics Snapshot Validation**:
```typescript
function validateSnapshot(snapshot: unknown): snapshot is AnalyticsSnapshot {
  if (typeof snapshot !== 'object' || snapshot === null) return false;
  const s = snapshot as Record<string, unknown>;
  
  return (
    typeof s.timestamp === 'string' &&
    isValidISO8601(s.timestamp) &&
    typeof s.localCount === 'number' &&
    s.localCount >= 0 &&
    typeof s.remoteCount === 'number' &&
    s.remoteCount >= 0 &&
    typeof s.totalCount === 'number' &&
    s.totalCount >= 0 &&
    typeof s.bothCount === 'number' &&
    s.bothCount >= 0 &&
    typeof s.unknownCount === 'number' &&
    s.unknownCount >= 0
  );
}
```

**Time Series Data Point Validation**:
```typescript
function validateDataPoint(point: unknown): point is TimeSeriesDataPoint {
  if (typeof point !== 'object' || point === null) return false;
  const p = point as Record<string, unknown>;
  
  const validGranularities = ['hourly', 'daily', 'weekly', 'monthly'];
  
  return (
    typeof p.periodStart === 'string' &&
    isValidISO8601(p.periodStart) &&
    typeof p.periodEnd === 'string' &&
    isValidISO8601(p.periodEnd) &&
    new Date(p.periodStart) <= new Date(p.periodEnd) &&
    typeof p.granularity === 'string' &&
    validGranularities.includes(p.granularity) &&
    typeof p.localCount === 'number' &&
    p.localCount >= 0 &&
    typeof p.remoteCount === 'number' &&
    p.remoteCount >= 0 &&
    typeof p.totalCount === 'number' &&
    p.totalCount >= 0 &&
    typeof p.snapshotCount === 'number' &&
    p.snapshotCount >= 1
  );
}
```

## Error Handling

### Invalid Data Points

- **Strategy**: Skip invalid data points, log warning to console
- **User Impact**: Display partial data with warning message if critical fields missing
- **Fallback**: If entire dataset invalid, show error state with retry option

### Missing Data

- **Strategy**: Display empty state UI with informative message
- **User Impact**: Show "No analytics data available yet" message
- **Fallback**: Ensure UI controls remain functional (filters, granularity, theme)

### Stale Data

- **Strategy**: Display cached data with staleness indicator
- **User Impact**: Show "Showing cached data from [timestamp]" banner
- **Fallback**: Provide manual refresh button

## Performance Considerations

### Large Datasets

- **Threshold**: > 1000 data points
- **Strategy**: Client-side data decimation/sampling
- **Implementation**: Sample data points to reduce rendering load while maintaining visual accuracy

### Progressive Loading

- **Strategy**: Load default time range, expand on demand
- **Default Ranges**:
  - Daily: Last 30 days
  - Weekly: Last 12 weeks
  - Monthly: Last 12 months
- **Implementation**: Fetch only required time range, lazy load historical data

## TypeScript Definitions

See `lib/types/analytics.ts` for complete TypeScript type definitions.



